{"version":3,"sources":["webpack:///src/index.vue","webpack:///demo-src/App.vue"],"names":[],"mappings":";AAkPA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACA;;;AC5IA;EACA;EACA;AACA;AAEA;EACA;AACA;AAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACA;AAEA;EACA;EACA;EACA;AACA","file":"65fe494b67fa20b1d782.css","sourcesContent":["<template>\n  <div class=\"infinite-scroll\" @click=\"onClick\">\n    <slot :state=\"state\" :error=\"error\" :auto=\"auto\" :direction=\"direction\">\n      <template v-if=\"state === 'loading'\">\n        Loading...\n      </template>\n\n      <template v-else-if=\"state === 'empty'\">\n        Empty\n      </template>\n\n      <template v-else-if=\"state === 'end'\">\n        End\n      </template>\n\n      <template v-else-if=\"state === 'error'\">\n        An error occurred. Click to retry.\n      </template>\n\n      <template v-else-if=\"state === 'standby' && auto !== 'in-advance'\">\n        {{ auto ? `Scroll ${direction} to load more` : 'Click to load more' }}\n      </template>\n    </slot>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'InfiniteScroll',\n\n  props: {\n    handler: Function,\n    head: {},\n    next: {},\n\n    direction: {\n      type: String,\n      default: 'down'\n    },\n\n    auto: {\n      default: 'in-advance' // in-advance, in-viewport\n    }\n  },\n\n  data: () => ({\n    state: 'standby',\n    error: {}\n  }),\n\n  watch: {\n    auto(b) {\n      if (b) {\n        this.addListeners()\n        this.check()\n      } else {\n        this.removeListeners()\n      }\n    },\n\n    next() {\n      this.setState()\n\n      if (this.direction === 'up' && this.head &&\n        (this.scrollContainer !== window || !('overflowAnchor' in document.body.style) || this.getScrollY() === 0)\n      ) {\n        this.restorePosition()\n      }\n\n      if (this.auto === 'in-advance') {\n        this.check()\n      }\n    }\n  },\n\n  created() {\n    this.setState()\n  },\n\n  mounted() {\n    this.scrollContainer = this.getScrollContainer(this.$el)\n\n    if (this.auto) {\n      this.addListeners()\n\n      if (this.auto === 'in-advance') {\n        this.check()\n      } else if (this.direction === 'up' && this.inViewport()) {\n        let y\n        const top = this.$el.getBoundingClientRect().top\n\n        if (this.scrollContainer === window) {\n          y = top + 1\n        } else {\n          y = top - this.scrollContainer.getBoundingClientRect().top + 1\n        }\n\n        this.scrollContainer.scrollBy(0, y)\n      }\n    }\n  },\n\n  destroyed() {\n    this.removeListeners()\n  },\n\n  methods: {\n    getScrollContainer(el) {\n      const parent = el.parentNode\n\n      if (parent === document.body) {\n        return window\n      } else {\n        if (['scroll', 'auto'].includes(window.getComputedStyle(parent).overflowY)) {\n          return parent\n        } else {\n          return this.getScrollContainer(parent)\n        }\n      }\n    },\n\n    setState() {\n      this.state = this.next === null\n        ? this.head\n          ? 'end'\n          : 'empty'\n        : 'standby'\n    },\n\n    onClick() {\n      if (this.state === 'standby' || this.state === 'error') {\n        this.load()\n      }\n    },\n\n    async load() {\n      this.state = 'loading'\n      this.error = null\n\n      if (this.direction === 'up') {\n        this.savePosition()\n      }\n\n      try {\n        await this.handler()\n      } catch (e) {\n        this.state = 'error'\n        this.error = e\n      }\n    },\n\n    savePosition() {\n      this.lastHead = this.head\n\n      this.spacing = this.head\n        ? document.querySelector(`[data-inf-id=\"${this.head}\"]`).getBoundingClientRect().top -\n          this.$el.getBoundingClientRect().bottom\n        : 0\n    },\n\n    restorePosition() {\n      console.log('restorePosition')\n\n      const y = this.lastHead\n        ? this.getScrollY() +\n          document.querySelector(`[data-inf-id=\"${this.lastHead}\"]`).getBoundingClientRect().top -\n          this.$el.getBoundingClientRect().bottom - this.spacing\n        : this.getScrollHeight() - this.getClientHeight()\n\n      this.scrollContainer.scrollTo(0, y)\n    },\n\n    getClientHeight() {\n      return this.scrollContainer === window\n        ? window.innerHeight\n        : this.scrollContainer.clientHeight\n    },\n\n    getScrollHeight() {\n      return this.scrollContainer === window\n        ? document.documentElement.scrollHeight\n        : this.scrollContainer.scrollHeight\n    },\n\n    getScrollY() {\n      return this.scrollContainer === window\n        ? window.scrollY\n        : this.scrollContainer.scrollTop\n    },\n\n    check() {\n      if (this.state === 'standby' && !this.timer) {\n        this.timer = setTimeout(() => {\n          this.timer = null\n\n          if (this.auto === 'in-advance' && this.isNear() || this.auto === 'in-viewport' && this.inViewport()) {\n            this.load()\n          }\n        })\n      }\n    },\n\n    isNear() {\n      const y = this.getScrollY()\n      const h = this.getScrollHeight()\n\n      return this.direction === 'down' && h - y < window.screen.height * 2 ||\n        this.direction === 'up' && y < window.screen.height\n    },\n\n    inViewport() {\n      const rect = this.$el.getBoundingClientRect()\n\n      if (this.scrollContainer === window) {\n        if (rect.top >= 0 && rect.bottom <= window.innerHeight) {\n          return true\n        }\n      } else {\n        const contRect = this.scrollContainer.getBoundingClientRect()\n\n        if (rect.top >= contRect.top && rect.bottom <= contRect.bottom) {\n          return true\n        }\n      }\n\n      return false\n    },\n\n    addListeners() {\n      this.scrollContainer.addEventListener('scroll', this.check)\n      window.addEventListener('resize', this.check)\n    },\n\n    removeListeners() {\n      this.scrollContainer.removeEventListener('scroll', this.check)\n      window.removeEventListener('resize', this.check)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.infinite-scroll {\n  font-size: 0.8em;\n  color: #666;\n  margin: 1em 0;\n  height: 2em;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  overflow-anchor: none;\n}\n</style>\n","<template>\n  <main>\n    <button class=\"btn-reset\" @click=\"reset\">reset</button>\n\n    <!-- infinite scroll up -->\n    <InfiniteScroll\n      v-if=\"items.length\"\n      direction=\"up\"\n      auto=\"in-viewport\"\n      :head=\"items[0] && items[0].id\"\n      :next=\"prev\"\n      :handler=\"loadPrevPage\"\n    />\n\n    <ul>\n      <!--\n        If you use upward infinite scroll, `data-inf-id` should be set.\n        If you use downward infinite scroll, it is not needed.\n      -->\n      <li\n        v-for=\"item in items\"\n        :key=\"item.id\"\n        :data-inf-id=\"item.id\"\n        :style=\"{ background: `hsl(${item.color.join()})` }\"\n      >\n        {{ item.id }}\n      </li>\n    </ul>\n\n    <!-- infinite scroll down -->\n    <InfiniteScroll\n      :head=\"items.length\"\n      :next=\"next\"\n      :handler=\"loadNextPage\"\n    />\n  </main>\n</template>\n\n<script>\nimport InfiniteScroll from '../src'\n\nconst limit = 10\n\nexport default {\n  components: { InfiniteScroll },\n\n  data: () => ({\n    items: [],\n    prev: 4,\n    next: 5\n  }),\n\n  methods: {\n    async loadNextPage() {\n      console.log(Date.now(), 'loadNextPage')\n      const page = this.next\n      const { items, totalCount } = await this.getMockData({ limit, page })\n\n      if (page === this.next) {\n        this.items = this.items.concat(items)\n        this.next = totalCount / limit > page ? page + 1 : null\n        console.log('next:', this.next)\n      }\n    },\n\n    async loadPrevPage() {\n      console.log(Date.now(), 'loadPrevPage')\n      const page = this.prev\n      const { items } = await this.getMockData({ limit, page })\n\n      if (page === this.prev) {\n        this.items = items.concat(this.items)\n        this.prev = page - 1 || null\n        console.log('prev:', this.prev)\n      }\n    },\n\n    async getMockData({ limit = 10, page = 1 } = {}) {\n      console.log('page:', page)\n      await new Promise(resolve => setTimeout(resolve, Math.random() * 2000))\n\n      // if (Math.random() > 0.7) {\n      //   throw new Error('server error')\n      // }\n\n      const totalCount = 100\n      const start = (page - 1) * limit\n      const end = Math.min(start + limit, totalCount)\n      const items = []\n\n      for (let i = start; i < end; i++) {\n        const color = [360 / (totalCount - 1) * i, '67%', '67%']\n        items.push({ id: i + 1, color })\n      }\n\n      return {\n        items,\n        totalCount\n      }\n    },\n\n    reset() {\n      this.items = []\n      this.prev = 4\n      this.next = 5\n    }\n  }\n}\n</script>\n\n<style scoped>\nmain {\n  max-width: 600px;\n  margin: 0 auto;\n}\n\nul {\n  padding: 0;\n}\n\nli {\n  margin: 10px;\n  list-style: none;\n  height: 128px;\n  border-radius: 4px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  font-size: 18px\n}\n\n.btn-reset {\n  position: fixed;\n  right: 0;\n  top: 0;\n}\n</style>\n"],"sourceRoot":""}